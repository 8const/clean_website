<html>
        <head>

                <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css')}}"/>
     
        </head>
        <body>
                        <div class="content">
		<center>
                        <h1>  <a href="../">  Constantine Larionoff <a> </h1>
                <h2>
                        <div id="row"> <a href="../neural_network/0"> NEURAL&nbsp;NETWORK </a>     </div>     

                        <div id="row">   <a href="../cellular_automata/">    CELLULAR&nbspAUTOMATA </a> </div>     

                        <div id="row">   <a href="../path_finding/">      PATH&nbsp;FINDING    </a>  </div>     
                </h2>

                              <hr>
	
                

                <div id="b">
                        <p>
                        <p>
    <center>
                        <h3 id="b"> This is not a convolutional neural netwok. It only has dense layers. So it's not good. But it's trying its best. </h3>
                        <p>

		 <form id="MyForm" action="predict" method="POST" enctype="multipart/form-data"> 
                         <p>
                <canvas id="myPics" width="28" height="28" style="border: 4px solid #002fa7;">
                        <style>

canvas {
  image-rendering: -moz-crisp-edges;
  image-rendering: -webkit-crisp-edges;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
touch-action:none;
}
 </style>

                <script>

function clearr() {
  context.clearRect(0, 0, myPics.width, myPics.height);
}

function savee() {
    var image = myPics.toDataURL("image/png").replace("image/png", "image/octet-stream"); 
    window.location.href=image;
}


function getStuff() {
    var image = new Image();
    var url = document.getElementById('url');
    image.id = "pic";
    image.src = myPics.toDataURL();
    url.value = image.src;

}
function ggetStuff() {
        var canvas  = document.getElementById('myPics');
        var url     = document.getElementById('url');
        var dataURL = canvas.toDataURL();
        url.value   = dataURL;
}









// Set up the canvas
var canvas = document.getElementById("myPics");
canvas.style.width  = "280px";
canvas.style.height = "280px";






canvas.addEventListener("mouseleave", function() {
  ggetStuff();
  submit = document.getElementById("predict");
  submit.click();
});





var ctx = canvas.getContext("2d");
ctx.strokeStyle = "#222222";
ctx.lineWidth = 2;
ctx.lineCap = "round";

// Set up mouse events for drawing
var drawing = false;
var mousePos = { x:0, y:0 };
var lastPos = mousePos;
canvas.addEventListener("mousedown", function (e) {
        drawing = true;
  lastPos = getMousePos(canvas, e);
}, false);
canvas.addEventListener("mouseup", function (e) {
  drawing = false;
}, false);
canvas.addEventListener("mousemove", function (e) {
  mousePos = getMousePos(canvas, e);
}, false);

// Get the position of the mouse relative to the canvas
function getMousePos(canvasDom, mouseEvent) {
  var rect = canvasDom.getBoundingClientRect();
  return {
    x: (mouseEvent.clientX - rect.left)/10,
    y: (mouseEvent.clientY - rect.top)/10
  };
}
// Get a regular interval for drawing to the screen
window.requestAnimFrame = (function (callback) {
        return window.requestAnimationFrame || 
           window.webkitRequestAnimationFrame ||
           window.mozRequestAnimationFrame ||
           window.oRequestAnimationFrame ||
           window.msRequestAnimaitonFrame ||
           function (callback) {
        window.setTimeout(callback, 1000/60);
           };
})();

// Draw to the canvas
function renderCanvas() {
  if (drawing) {
    ctx.moveTo(lastPos.x, lastPos.y);
    ctx.lineTo(mousePos.x, mousePos.y);
    ctx.stroke();
    lastPos = mousePos;
  }
}

// Allow for animation
(function drawLoop () {
  requestAnimFrame(drawLoop);
  renderCanvas();
})();

// Set up touch events for mobile, etc
canvas.addEventListener("touchstart", function (e) {
        mousePos = getTouchPos(canvas, e);
  var touch = e.touches[0];
  var mouseEvent = new MouseEvent("mousedown", {
    clientX: touch.clientX,
    clientY: touch.clientY
  });
  canvas.dispatchEvent(mouseEvent);
}, false);
canvas.addEventListener("touchend", function (e) {
  var mouseEvent = new MouseEvent("mouseup", {});
  canvas.dispatchEvent(mouseEvent);
}, false);
canvas.addEventListener("touchmove", function (e) {
  var touch = e.touches[0];
  var mouseEvent = new MouseEvent("mousemove", {
    clientX: touch.clientX,
    clientY: touch.clientY
  });
  canvas.dispatchEvent(mouseEvent);
}, false);

// Get the position of a touch relative to the canvas
function getTouchPos(canvasDom, touchEvent) {
  var rect = canvasDom.getBoundingClientRect();
  return {
    x: (touchEvent.touches[0].clientX - rect.left)/10,
    y: (touchEvent.touches[0].clientY - rect.top)/10
  };
}


// Prevent scrolling when touching the canvas
document.body.addEventListener("touchstart", function (e) {
  if (e.target == canvas) {
    e.preventDefault();
  }
}, false);
document.body.addEventListener("touchend", function (e) {
  if (e.target == canvas) {
    e.preventDefault();
  }
}, false);
document.body.addEventListener("touchmove", function (e) {
  if (e.target == canvas) {
    e.preventDefault();
  }
}, false);





var element = canvas;
document.addEventListener('touchstart', function(event) {
    event.preventDefault();
    var touch = event.touches[0];
    element = document.elementFromPoint(touch.pageX,touch.pageY);
}, false);

</script>
</canvas>
<input type="hidden" id="url" name="url" value="kek">
<p>
<style>
#predict {

        color:#002fa7;
        font-family: Helvetica;
	font-weight: 324; 
	font-size: 40pt;
	background: transparent;
        border: none;
        margin-bottom: 16px;

}
</style>

<h2> <input onclick="ggetStuff();" type="submit" id="predict" value="PREDICT"> </h2>
</form>


<h1> {{number}} </h1>

                        <h3> Why is it so bad? </h3>
                                
                    <p class="t"> 
                   One doesn't have to be an expert in machine learning to notice how terrible this model is. I think about 30 lines of Keras/PyTorch can specify, compile and train a model that's 10x better than this one. And I could do it. But I didn't. Because anyone can do it. Very few people however are capable of creating a beast as ferociaus as the one presented above.
                    </p>
                    <p class="t"> This neural network is my child. I made it myself from first principles. I started with drawing it on paper and writing a forward pass, thinking about every neuron. I then wrote it using the matrix notation and verified that shapes were right. Then I spent a month working out the math of derivatives with respect to each parameter. It was by far the hardest part. I made many mistakes and started from nothing again and again. Then the shapes matched and I knew it must have been right. I procceded and wrote a mini-batch gradient desent in 10 minutes. And it worked. Buy the way it wasn't exactly this neural network. That one just classified nmbers between 0 and 1 in 2 categories based on them being > 0.5 .</p>
                    <p class="t"> But I truly apreciated how that model doing an absolutely useless task could in a day of my rather unskilled work be tranformed and retrained into more or less working classifier for images. That was a moment of pure joy when it recognised MNIST test example[0] as 7. I got 95% accuracy on test data and was quite happy. But turns out it doesn't extrapolate particulary well to other images of slightly different nature. Such as the ones drawn here.
                    </p> <p class="t">
                        It nevertheless does a decent job at recognizing 0, 1, 2, 3, 4, 5. It absolutely hates number 8. If 7 and 9 are small it recognises them. There is a trick in how to draw 6 suh that it works. But I'm not telling you it. Figure it out as I did. 
                        </p>

        </body>
        </html>

